/*
 * Copyright 2018 Arthur Ivanets, arthur.ivanets.l@gmail.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.arthurivanets.mvvm

import android.os.Bundle
import androidx.annotation.CallSuper
import androidx.lifecycle.ViewModel
import com.arthurivanets.mvvm.events.ViewModelEvent
import com.arthurivanets.mvvm.util.CompositeMapDisposable
import com.arthurivanets.mvvm.util.adapt
import com.arthurivanets.rxbus.BusEvent
import com.arthurivanets.rxbus.EventSource
import com.arthurivanets.rxbus.android.AndroidRxBus
import io.reactivex.disposables.Disposable
import io.reactivex.functions.Consumer

/**
 * An abstract implementation of the [BaseViewModel].
 * <br>
 * (Extend your concrete [ViewModel] implementations from this class)
 */
abstract class AbstractViewModel : ViewModel(), BaseViewModel {


    private val eventBus = AndroidRxBus.newInstance()

    private val shortLivingDisposables = CompositeMapDisposable<String>()
    private val longLivingDisposables = CompositeMapDisposable<String>()

    private val eventHandler = Consumer(::onEvent)


    @CallSuper
    override fun onStart() {
        //
    }


    @CallSuper
    override fun onStop() {
        clearShortLivingDisposables()
    }


    @CallSuper
    override fun onCleared() {
        shortLivingDisposables.dispose()
        longLivingDisposables.dispose()
        super.onCleared()
    }


    override fun onBackPressed() : Boolean {
        return false
    }


    @CallSuper
    override fun onRestoreState(bundle : Bundle) {
        //
    }


    @CallSuper
    override fun onSaveState(bundle : Bundle) {
        //
    }


    /**
     * Used for the delivery of the Events generated by....
     */
    @CallSuper
    protected open fun onEvent(event : BusEvent<*>) {
        //
    }


    /**
     * Registers the specified [EventSource] for further consumption of the corresponding
     * emitted events in the [onEvent] method.
     * <br>
     * The exact management of the lifecycle of the subscription is taken care of internally.
     */
    protected fun <T : BusEvent<*>> registerEventEmitter(eventEmitter : EventSource<T>) {
        eventEmitter.subscribe(eventHandler.adapt()).manageLongLivingDisposable()
    }


    final override fun subscribe(eventConsumer : Consumer<ViewModelEvent<*>>) : Disposable {
        return this.eventBus.register(ViewModelEvent::class.java, eventConsumer)
    }


    /**
     * Dispatches the [ViewModelEvent] to its final destination (the owning View).
     * <br>
     * (The event will be delivered if and only if the owning View has an active subscription to the current ViewModel)
     */
    protected fun dispatchEvent(event : ViewModelEvent<*>) {
        eventBus.post(event)
    }


    /**
     * Adds the specified disposable to the registry of Short-living [Disposable]s.
     * <br>
     * (If there's an active short-living [Disposable] associated with the same key, it will be disposed)
     * <br>
     * <br>
     * Short Living [Disposable]s are automatically disposed whenever the [BaseViewModel]'s
     * [BaseViewModel.onStop] method is called.
     *
     * @param key the key to associate with this disposable
     */
    protected fun Disposable.manageShortLivingDisposable(key : String = this.hashCode().toString()) {
        disposeShortLivingDisposable(key)
        shortLivingDisposables[key] = this
    }


    /**
     * Disposes the active Short-living [Disposable] that's associated with the specified key (if there's any).
     */
    protected fun disposeShortLivingDisposable(key : String) {
        shortLivingDisposables.remove(key)?.dispose()
    }


    /**
     * Disposes all the Short-living [Disposable]s that are present within
     * the Short-living [Disposable]s Registry.
     */
    protected fun clearShortLivingDisposables() {
        shortLivingDisposables.clear()
    }


    /**
     * Adds the specified disposable to the registry of Long-living [Disposable]s.
     * <br>
     * (If there's an active long-living [Disposable] associated with the same key, it will be disposed)
     * <br>
     * <br>
     * Long Living [Disposable]s are automatically disposed whenever the [ViewModel]'s
     * [ViewModel.onCleared] method is called.
     *
     * @param key the key to associate with this disposable
     */
    protected fun Disposable.manageLongLivingDisposable(key : String = this.hashCode().toString()) {
        disposeLongLivingDisposable(key)
        longLivingDisposables[key] = this
    }


    /**
     * Disposes the active Long-living [Disposable] that's associated with the specified key (if there's any).
     */
    protected fun disposeLongLivingDisposable(key : String) {
        longLivingDisposables.remove(key)?.dispose()
    }


    /**
     * Disposes all the Long-living [Disposable]s that are present within
     * the Long-living [Disposable]s Registry.
     */
    protected fun clearLongLivingDisposables() {
        longLivingDisposables.clear()
    }


}